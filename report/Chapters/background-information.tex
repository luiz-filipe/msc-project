\chapter{Background Information}
\label{ch:background-information}

\section {Social Insects}

\section {Communication}
\label{sec:ant-comm}

tell that differnt pheromone types have different ranges and decay faster or slower.
warning must decay fast and have a greater action area than forage for example, explain why.

\subsection{Ants}



\section{Emergence}

Emergence is one of the concepts that are difficult to define. It is present in many different areas like science, arts and philosophy. It is seen throughout nature in phenomena such patterns on the sand in the desert and flock of birds.

A general concept of emergence can be defined as decentralised, local behaviour when seem from a higher perspective aggregates into a global behaviour. As local behaviour is not directly connected to the global behaviour, it does not matter to the aggregate outcome. That is, the agents that have local behaviour do not share a global behaviour as target.

There are multiple layers of emergence, and this is very important concept to understand complex systems.\cite{miller2007complex} As example one could take is any of most of the multi-cellular animals, including ourselves. The theoretical biologist \citeauthor{life1010034} argues that life is an emergent event itself. If we stop to think for a moment, there are trillions of cells in our body, each of them concerned only with their very specific context. Many of  them replaced daily, in a couple of years we are very likely to not have any cell that is in our body today, but we will continue to be what we are today, at least physically.

Emergence is not a new concept, it has been around for a long time. A good example of this is the Central Limit Theorem (CLT), which was first postulated in 1733 by the mathematician Abraham de Moivre. \cite{tijms2007understanding}. In few words the CLT states that, if certain conditions are satisfied, the mean of a large number of independent random variables will be distributed following a normal distribution.

\subsection{Types of emergence}

Typically emergence is split into weak and strong. It is possible to say that a phenomenon is strong emergent when it arises from a low-level domain, but the new qualities that these phenomenon bring to the system are irreducible to the system's constituent parts.\cite{laughlin2008different} As an example of strong emergence we can turn to ant colonies. Some ant colonies when are defending their queen, recruit workers to create a semi-sphere of ants around the queen, keeping it safe. The resulting global behaviour cannot be traced back to any individual worker. Now a weak emergence describes properties that can be reducible to its individual constituents. 

\subsection{Feedback}
\label{subsec:feedback}

When agents are interacting to each other, and these interactions are not independent, feedback becomes a very important part of complex systems. If the feedback is positive, disturbance on the system get amplified, leading to instability. A good example of positive feedback can be borrowed from Chemistry. In case of a chemical reaction happens faster at higher temperatures, but the reaction itself releases heat, it is very likely a positive feedback loop will be created and the reaction could lead to explosion very quickly.

On the other hand, if the feedback is negative, any disturbance on the system is absorbed, taking the system to a state of stability. There are many examples of positive feedback in our own body.Secretion of sweat to regulate body temperature and secretion of a variety of hormones to regulate from water absorption to salt absorption.  

\subsection{Decentralised Systems}

Systems that lack a central authority are called decentralised. In their most common form they are self-regulated, they are present in a vast range of domains, from nature to our society. Sock market is one example of such system. Although there are regulatory instruments in place to avoid abuse, the large number of dealers regulate the market as long as the value of shares are concerned. Imagine that for some reason a share is particularly attractive, so people are likely to buy it. Following the the high demand for the share, its price will rise. After some certain point, due its high price, the share will not be as much attractive anymore and agents involved in trading will go after other options. With time the demand for the share will get weaker and its price is likely to go down.

Of course this is an oversimplified version of what actually happens, but the important point here is that the agents involved in process of buying and selling the share regulate its price themselves. They are autonomous regarding taking the decision to buy or sell.

Arguably this property is the foundation of emergent systems. The autonomy of the system's components allows complex behaviour to emerge in a way that in centralised system it would not occur, actually in cases of centralised systems co-ordination is key. Indeed complex behaviour is capable of emerging in such systems, but only as a byproduct of this co-ordination. (((need and example here, but is going to be difficult to find)))

\section{Agent-based Object Models}

Agent-based modelling has proved to be one of the most relevant research areas in computing in the last decade. Nowadays we are overwhelmed by the amount of information available to us, and with the improvements on hardware in the last two decades gave some of the tools to use this available information in ways it was not possible before. Agent technology enters the scene taking advantage of these improvements and opens up a whole new world for new technologies to be created and put in use, wether for research or in  commercial applications. Different domains like biology, game theory, stock market and evolutionary computing are using agents extensively, from simulation on animal populations (((cite))) to predicting market patterns (((cite))).

An agent can be defined as a computational entity that is autonomous and exhibits flexible behaviour. Agents are also responsible over their own internal state. Usually agents are usually placed in environments that are dynamic and unpredictable. By flexible behaviour three main aspects are of most importance\cite{wooldridge2009introduction} :

\begin{enumerate}
\item Reactive: In most of the applications that agent technology is deployed the environment is not static. That is, it changes over time. A reactive system is capable of responding to the changes in the environment in the best way possible in order to the system to continue operating as it was before the changes had been introduced. 

\item Pro-active: Reacting only to a dynamic environment most of the times is not enough. Agents have have a reason to be, something to achieve, a goal. So it is crucial that agents not just react, but take the initiative to achieve their goals.

\item Social: Agents are likely to be deployed in a multi-agent environment, in some cases there can be some goals that are achieved only if agents cooperate with each other. Thus, social ability, that is being able to interact with other agents is vital.
\end{enumerate}

Agent technology provides a variety of standards and tools empowering designers and developers to structure applications around autonomous and communicative components from their concept to their implementation.\cite{al3roadmap}

All in all, agent-oriented modelling offer the best methodology and standards ecosystem for representing complex dynamic systems.

\subsection{Agents and Objects}

It is important to make the distinction between agents and objects. Objects are all about encapsulating state and providing methods to execute operation upon it. Objects do communicate, through messaging or method invocation, but they are passive. Objects and Object Oriented Programming (OOP) are merely the means to build agent systems. Agent-oriented modelling is a whole new programming paradigm. 

\subsection{Agents as a Theoretical Tool}

Another way to see Agent-oriented modelling is as a new kind of tool that empower us to touch questions that are very difficult to be addressed with traditional tools like mathematical methods. A tool that is particularly suited to deal with complex social systems.

In comparison with traditional tools, computational models sit at the other site of the spectrum. Traditional tools are static, precise and timeless; computational model are dynamic, flexible and timely. Even more, computational models are flexible enough in a way that we can add complexity to them in order to gain precision. So it is as if the computational model precision is a variable that we can control as we want or need to.

At a first moment it is hard to look at computational models as a science tool at the same level of mathematical methods that have been used for centuries to built good part of our knowledge of phenomena that surround us. But the problems we are committed to tackle today are different from the ones people were working on in the past and Agent-oriented modelling provides a powerful framework, which by its nature is well suited against this new class of complex problems.

\citeauthor{miller2007complex} present a in-depth discussion on the contrasts of traditional methods and computational models. As well as a list of the advantages of Agent-oriented modelling over traditional methods. 

\section{Parallel Programming}

\subsection{Threads And Task Execution}
\label{subsec:threads-task-exec}

In Java terms, threads are the mechanisms that are used to run tasks asynchronously, and it is a common mistake to think that the \emph{Thread} class is the primary abstraction for task execution in the language, but in fact the \emph{Executor} interface is. It is the base of a powerful task execution framework. It is important to note that the executors follow the producer-consumer pattern.

Java provides the \emph{Executors} factory to create thread pools for task execution. Using thread pools has many advantages over manually managing threads' lifecycle. It is possible to reuse threads to execute more than one task, what minimises the cost of creating and stoping threads, speeding up task execution. There are four methods provided by the \emph{Executors} factory for creating thread pools, for this project the most important are: \emph{newFixedThreadPool} and \emph{newScheduledThreadPool}. The former create a fixed-sized thread pool, tasks are executed as soon as submitted, when the fixed limit number is reached the tasks have wait until a thread is available to execute. The latter allows the creation of fixed-size thread pool as well, but in this case the pool supports delayed and periodic task execution.

The basic representation of a task in Java is the \emph{Runnable} interface, but tasks implementing \emph{Runnable} are not able to return a value or throw checked exceptions.\cite{goetz2006java} Now the \emph{Callable} interface is a richer abstraction of tasks, they allow the task to return a value and to throw checked exceptions. 

Tasks executed by an \emph{Executor} can have various states, as far as this project is concerned these states are not critical, because all the simulations run are to investigate the colony at a point in time only, so in all the cases, the thread pools will be created to the size of the number of agents necessary to run the simulation.

Now the \emph{Future} interface is an abstraction of the state of a task moving forward, it provides useful methods to manage and retrieve results of tasks.

So the natural way of executing tasks is to create a thread pool using an \emph{Executor} such as \emph{ExecutorService}, then submitting tasks to it, any classes that implement \emph{Runnable} or \emph{Callable}. The methods used for task submission are likely to return \emph{Future} objects that represent the task state. These objects can be used for a variety of things, like exception checking for instance.

\section{Current research}